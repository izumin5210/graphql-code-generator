"use strict";(self.webpackChunk_graphql_codegen_website=self.webpackChunk_graphql_codegen_website||[]).push([[9827],{70677:function(e,n,i){i.d(n,{Z:function(){return o}});var t=i(64013);function o(e,n){var i="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(i)return(i=i.call(e)).next.bind(i);if(Array.isArray(e)||(i=(0,t.Z)(e))||n&&e&&"number"==typeof e.length){i&&(e=i);var o=0;return function(){return o>=e.length?{done:!0}:{done:!1,value:e[o++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}},52198:function(e,n,i){i.d(n,{jf:function(){return me}});var t=i(37358),o=i(5776),s=i(43165),r=i(33277),l=i(23476),a=i(57554),c=i(12640),u=i(65449),d=i(14734),f=i(83755),v=i(79945),p=i(82299),m=i(43903),y=i(30138);function T(e,n,i){const o=(0,c.nN)(e)?{schema:e,resolvers:null!=n?n:{},resolverValidationOptions:i}:e;let{schema:s,resolvers:r,defaultFieldResolver:l,resolverValidationOptions:a={},inheritResolversFromInterfaces:u=!1,updateResolversInPlace:d=!1}=o;const{requireResolversToMatchSchema:p="error",requireResolversForResolveType:m}=a,T=u?function(e,n){const i={},t=e.getTypeMap();for(const o in t){const e=t[o];if("getInterfaces"in e){i[o]={};for(const s of e.getInterfaces())if(n[s.name])for(const e in n[s.name])"__isTypeOf"!==e&&e.startsWith("__")||(i[o][e]=n[s.name][e]);const t=n[o];i[o]={...i[o],...t}}else{const e=n[o];null!=e&&(i[o]=e)}}return i}(s,r):r;for(const t in T){const e=T[t];if("object"!==typeof e)throw new Error(`"${t}" defined in resolvers, but has invalid value "${e}". The resolver's value must be of type object.`);const n=s.getType(t);if(null==n){if("ignore"===p)break;throw new Error(`"${t}" defined in resolvers, but not in schema`)}if((0,v.u1)(n))for(const i in e)i.startsWith("__")?n[i.substring(2)]=e[i]:n[i]=e[i];else if((0,f.EM)(n)){const i=n.getValues();for(const t in e)if(!t.startsWith("__")&&!i.some((e=>e.name===t))&&p&&"ignore"!==p)throw new Error(`${n.name}.${t} was defined in resolvers, but not present within ${n.name}`)}else if((0,f.EN)(n)){for(const i in e)if(!i.startsWith("__")&&p&&"ignore"!==p)throw new Error(`${n.name}.${i} was defined in resolvers, but ${n.name} is not an object or interface type`)}else if((0,f.lp)(n)||(0,f.oT)(n))for(const i in e)if(!i.startsWith("__")){if(null==n.getFields()[i]){if(p&&"ignore"!==p)throw new Error(`${t}.${i} defined in resolvers, but not in schema`)}else{const n=e[i];if("function"!=typeof n&&"object"!=typeof n)throw new Error(`Resolver ${t}.${i} must be object or function`)}}}return s=d?function(e,n,i){var o,s,r,l,a,c,u,d,v,p,m,y,T,h,N,_,g,x;const I=e.getTypeMap();for(const t in n){const i=e.getType(t),b=n[t];if((0,f.KA)(i))for(const e in b)e.startsWith("__")?i[e.substring(2)]=b[e]:"astNode"===e&&null!=i.astNode?i.astNode={...i.astNode,description:null!==(r=null===(s=null===(o=b)||void 0===o?void 0:o.astNode)||void 0===s?void 0:s.description)&&void 0!==r?r:i.astNode.description,directives:(null!==(l=i.astNode.directives)&&void 0!==l?l:[]).concat(null!==(u=null===(c=null===(a=b)||void 0===a?void 0:a.astNode)||void 0===c?void 0:c.directives)&&void 0!==u?u:[])}:"extensionASTNodes"===e&&null!=i.extensionASTNodes?i.extensionASTNodes=i.extensionASTNodes.concat(null!==(v=null===(d=b)||void 0===d?void 0:d.extensionASTNodes)&&void 0!==v?v:[]):"extensions"===e&&null!=i.extensions&&null!=b.extensions?i.extensions=Object.assign({},i.extensions,b.extensions):i[e]=b[e];else if((0,f.EM)(i)){const e=i.toConfig(),n=e.values;for(const t in b)t.startsWith("__")?e[t.substring(2)]=b[t]:"astNode"===t&&null!=e.astNode?e.astNode={...e.astNode,description:null!==(y=null===(m=null===(p=b)||void 0===p?void 0:p.astNode)||void 0===m?void 0:m.description)&&void 0!==y?y:e.astNode.description,directives:(null!==(T=e.astNode.directives)&&void 0!==T?T:[]).concat(null!==(_=null===(N=null===(h=b)||void 0===h?void 0:h.astNode)||void 0===N?void 0:N.directives)&&void 0!==_?_:[])}:"extensionASTNodes"===t&&null!=e.extensionASTNodes?e.extensionASTNodes=e.extensionASTNodes.concat(null!==(x=null===(g=b)||void 0===g?void 0:g.extensionASTNodes)&&void 0!==x?x:[]):"extensions"===t&&null!=i.extensions&&null!=b.extensions?i.extensions=Object.assign({},i.extensions,b.extensions):n[t]&&(n[t].value=b[t]);I[t]=new f.mR(e)}else if((0,f.EN)(i))for(const e in b)e.startsWith("__")&&(i[e.substring(2)]=b[e]);else if((0,f.lp)(i)||(0,f.oT)(i))for(const e in b){if(e.startsWith("__")){i[e.substring(2)]=b[e];break}const n=i.getFields()[e];if(null!=n){const i=b[e];"function"==typeof i?n.resolve=i.bind(b):E(n,i)}}}(0,t.pD)(e,t.RF),(0,t.r8)(e),(0,t.pD)(e,t.Oe),null!=i&&(0,t.pY)(e,(e=>{e.resolve||(e.resolve=i)}));return e}(s,T,l):function(e,n,i){e=(0,t.gf)(e,{[t.h0.SCALAR_TYPE]:e=>{var i,t,o,s,r,l,a,c,u;const d=e.toConfig(),p=n[e.name];if(!(0,v.u1)(e)&&null!=p){for(const n in p)n.startsWith("__")?d[n.substring(2)]=p[n]:"astNode"===n&&null!=d.astNode?d.astNode={...d.astNode,description:null!==(o=null===(t=null===(i=p)||void 0===i?void 0:i.astNode)||void 0===t?void 0:t.description)&&void 0!==o?o:d.astNode.description,directives:(null!==(s=d.astNode.directives)&&void 0!==s?s:[]).concat(null!==(a=null===(l=null===(r=p)||void 0===r?void 0:r.astNode)||void 0===l?void 0:l.directives)&&void 0!==a?a:[])}:"extensionASTNodes"===n&&null!=d.extensionASTNodes?d.extensionASTNodes=d.extensionASTNodes.concat(null!==(u=null===(c=p)||void 0===c?void 0:c.extensionASTNodes)&&void 0!==u?u:[]):"extensions"===n&&null!=d.extensions&&null!=p.extensions?d.extensions=Object.assign({},e.extensions,p.extensions):d[n]=p[n];return new f.n2(d)}},[t.h0.ENUM_TYPE]:e=>{var i,t,o,s,r,l,a,c,u;const d=n[e.name],v=e.toConfig(),p=v.values;if(null!=d){for(const n in d)n.startsWith("__")?v[n.substring(2)]=d[n]:"astNode"===n&&null!=v.astNode?v.astNode={...v.astNode,description:null!==(o=null===(t=null===(i=d)||void 0===i?void 0:i.astNode)||void 0===t?void 0:t.description)&&void 0!==o?o:v.astNode.description,directives:(null!==(s=v.astNode.directives)&&void 0!==s?s:[]).concat(null!==(a=null===(l=null===(r=d)||void 0===r?void 0:r.astNode)||void 0===l?void 0:l.directives)&&void 0!==a?a:[])}:"extensionASTNodes"===n&&null!=v.extensionASTNodes?v.extensionASTNodes=v.extensionASTNodes.concat(null!==(u=null===(c=d)||void 0===c?void 0:c.extensionASTNodes)&&void 0!==u?u:[]):"extensions"===n&&null!=v.extensions&&null!=d.extensions?v.extensions=Object.assign({},e.extensions,d.extensions):p[n]&&(p[n].value=d[n]);return new f.mR(v)}},[t.h0.UNION_TYPE]:e=>{const i=n[e.name];if(null!=i){const n=e.toConfig();return i.__resolveType&&(n.resolveType=i.__resolveType),new f.Gp(n)}},[t.h0.OBJECT_TYPE]:e=>{const i=n[e.name];if(null!=i){const n=e.toConfig();return i.__isTypeOf&&(n.isTypeOf=i.__isTypeOf),new f.h6(n)}},[t.h0.INTERFACE_TYPE]:e=>{const i=n[e.name];if(null!=i){const n=e.toConfig();return i.__resolveType&&(n.resolveType=i.__resolveType),new f.oW(n)}},[t.h0.COMPOSITE_FIELD]:(e,i,t)=>{const o=n[t];if(null!=o){const n=o[i];if(null!=n){const i={...e};return"function"==typeof n?i.resolve=n.bind(o):E(i,n),i}}}}),null!=i&&(e=(0,t.gf)(e,{[t.h0.OBJECT_FIELD]:e=>({...e,resolve:null!=e.resolve?e.resolve:i})}));return e}(s,T,l),(m||"ignore"!==m)&&function(e,n){(0,t.gf)(e,{[t.h0.ABSTRACT_TYPE]:e=>{if(!e.resolveType){const i=`Type "${e.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;if("error"===n)throw new Error(i);"warn"===n&&y.warn(i)}}})}(s,m),s}function E(e,n){for(const i in n)e[i]=n[i]}function h(e,n){if(!e||Array.isArray(e)&&0===e.length)return{};if(!Array.isArray(e))return e;if(1===e.length)return e[0]||{};const i=new Array;for(let t of e)Array.isArray(t)&&(t=h(t)),"object"==typeof t&&t&&i.push(t);const o=(0,t.Ee)(i,!0);if(null==n?void 0:n.exclusions)for(const t of n.exclusions){const[e,n]=t.split(".");n&&"*"!==n?o[e]&&delete o[e][n]:delete o[e]}return o}function N(e,n,i){const o=[...n,...e].filter(t.pC).reduce(((e,n)=>e.find((e=>e.name.value===n.name.value))?e:e.concat([n])),[]);return i&&i.sort&&o.sort(t.YU),o}let _={};function g(){_={}}function x(e){var n;const i=null===(n=e.name)||void 0===n?void 0:n.value;if(null!=i)switch(I(e,i),e.kind){case"EnumTypeDefinition":if(e.values)for(const n of e.values)I(n,i,n.name.value);break;case"ObjectTypeDefinition":case"InputObjectTypeDefinition":case"InterfaceTypeDefinition":if(e.fields)for(const n of e.fields)if(I(n,i,n.name.value),j(n)&&n.arguments)for(const e of n.arguments)I(e,i,n.name.value,e.name.value)}}function I(e,n,i,t){const s=(0,o.Eb)(e,{commentDescriptions:!0});if("string"!=typeof s||0===s.length)return;const r=[n];i&&(r.push(i),t&&r.push(t));const l=r.join(".");_[l]||(_[l]=[]),_[l].push(s)}function b(e){return"\n# "+e.replace(/\n/g,"\n# ")}function A(e,n){return e?e.filter((e=>e)).join(n||""):""}function O(e){var n;return null!==(n=null==e?void 0:e.some((e=>e.includes("\n"))))&&void 0!==n&&n}function S(e){return e&&`  ${e.replace(/\n/g,"\n  ")}`}function D(e){return e&&0!==e.length?`{\n${S(A(e,"\n"))}\n}`:""}function k(e,n,i){return n?e+n+(i||""):""}const F={Name:{leave:e=>e.value},Variable:{leave:e=>"$"+e.name},Document:{leave:e=>A(e.definitions,"\n\n")},OperationDefinition:{leave:e=>{const n=k("(",A(e.variableDefinitions,", "),")");return A([e.operation,A([e.name,n]),A(e.directives," ")]," ")+" "+e.selectionSet}},VariableDefinition:{leave:({variable:e,type:n,defaultValue:i,directives:t})=>e+": "+n+k(" = ",i)+k(" ",A(t," "))},SelectionSet:{leave:({selections:e})=>D(e)},Field:{leave({alias:e,name:n,arguments:i,directives:t,selectionSet:o}){const s=k("",e,": ")+n;let r=s+k("(",A(i,", "),")");return r.length>80&&(r=s+k("(\n",S(A(i,"\n")),"\n)")),A([r,A(t," "),o]," ")}},Argument:{leave:({name:e,value:n})=>e+": "+n},FragmentSpread:{leave:({name:e,directives:n})=>"..."+e+k(" ",A(n," "))},InlineFragment:{leave:({typeCondition:e,directives:n,selectionSet:i})=>A(["...",k("on ",e),A(n," "),i]," ")},FragmentDefinition:{leave:({name:e,typeCondition:n,variableDefinitions:i,directives:t,selectionSet:o})=>`fragment ${e}${k("(",A(i,", "),")")} on ${n} ${k("",A(t," ")," ")}`+o},IntValue:{leave:({value:e})=>e},FloatValue:{leave:({value:e})=>e},StringValue:{leave:({value:e,block:n})=>n?function(e,n=!1){const i=e.replace(/"""/g,'\\"""');return" "!==e[0]&&"\t"!==e[0]||-1!==e.indexOf("\n")?`"""\n${n?i:S(i)}\n"""`:`"""${i.replace(/"$/,'"\n')}"""`}(e):JSON.stringify(e)},BooleanValue:{leave:({value:e})=>e?"true":"false"},NullValue:{leave:()=>"null"},EnumValue:{leave:({value:e})=>e},ListValue:{leave:({values:e})=>"["+A(e,", ")+"]"},ObjectValue:{leave:({fields:e})=>"{"+A(e,", ")+"}"},ObjectField:{leave:({name:e,value:n})=>e+": "+n},Directive:{leave:({name:e,arguments:n})=>"@"+e+k("(",A(n,", "),")")},NamedType:{leave:({name:e})=>e},ListType:{leave:({type:e})=>"["+e+"]"},NonNullType:{leave:({type:e})=>e+"!"},SchemaDefinition:{leave:({description:e,directives:n,operationTypes:i})=>k("",e,"\n")+A(["schema",A(n," "),D(i)]," ")},OperationTypeDefinition:{leave:({operation:e,type:n})=>e+": "+n},ScalarTypeDefinition:{leave:({description:e,name:n,directives:i})=>k("",e,"\n")+A(["scalar",n,A(i," ")]," ")},ObjectTypeDefinition:{leave:({description:e,name:n,interfaces:i,directives:t,fields:o})=>k("",e,"\n")+A(["type",n,k("implements ",A(i," & ")),A(t," "),D(o)]," ")},FieldDefinition:{leave:({description:e,name:n,arguments:i,type:t,directives:o})=>k("",e,"\n")+n+(O(i)?k("(\n",S(A(i,"\n")),"\n)"):k("(",A(i,", "),")"))+": "+t+k(" ",A(o," "))},InputValueDefinition:{leave:({description:e,name:n,type:i,defaultValue:t,directives:o})=>k("",e,"\n")+A([n+": "+i,k("= ",t),A(o," ")]," ")},InterfaceTypeDefinition:{leave:({description:e,name:n,interfaces:i,directives:t,fields:o})=>k("",e,"\n")+A(["interface",n,k("implements ",A(i," & ")),A(t," "),D(o)]," ")},UnionTypeDefinition:{leave:({description:e,name:n,directives:i,types:t})=>k("",e,"\n")+A(["union",n,A(i," "),k("= ",A(t," | "))]," ")},EnumTypeDefinition:{leave:({description:e,name:n,directives:i,values:t})=>k("",e,"\n")+A(["enum",n,A(i," "),D(t)]," ")},EnumValueDefinition:{leave:({description:e,name:n,directives:i})=>k("",e,"\n")+A([n,A(i," ")]," ")},InputObjectTypeDefinition:{leave:({description:e,name:n,directives:i,fields:t})=>k("",e,"\n")+A(["input",n,A(i," "),D(t)]," ")},DirectiveDefinition:{leave:({description:e,name:n,arguments:i,repeatable:t,locations:o})=>k("",e,"\n")+"directive @"+n+(O(i)?k("(\n",S(A(i,"\n")),"\n)"):k("(",A(i,", "),")"))+(t?" repeatable":"")+" on "+A(o," | ")},SchemaExtension:{leave:({directives:e,operationTypes:n})=>A(["extend schema",A(e," "),D(n)]," ")},ScalarTypeExtension:{leave:({name:e,directives:n})=>A(["extend scalar",e,A(n," ")]," ")},ObjectTypeExtension:{leave:({name:e,interfaces:n,directives:i,fields:t})=>A(["extend type",e,k("implements ",A(n," & ")),A(i," "),D(t)]," ")},InterfaceTypeExtension:{leave:({name:e,interfaces:n,directives:i,fields:t})=>A(["extend interface",e,k("implements ",A(n," & ")),A(i," "),D(t)]," ")},UnionTypeExtension:{leave:({name:e,directives:n,types:i})=>A(["extend union",e,A(n," "),k("= ",A(i," | "))]," ")},EnumTypeExtension:{leave:({name:e,directives:n,values:i})=>A(["extend enum",e,A(n," "),D(i)]," ")},InputObjectTypeExtension:{leave:({name:e,directives:n,fields:i})=>A(["extend input",e,A(n," "),D(i)]," ")}},w=Object.keys(F).reduce(((e,n)=>{return{...e,[n]:{leave:(i=F[n].leave,(e,n,t,o,s)=>{var r;const l=[],a=o.reduce(((e,n)=>(["fields","arguments","values"].includes(n)&&e.name&&l.push(e.name.value),e[n])),s[0]),c=[...l,null===(r=null==a?void 0:a.name)||void 0===r?void 0:r.value].filter(Boolean).join("."),u=[];return e.kind.includes("Definition")&&_[c]&&u.push(..._[c]),A([...u.map(b),e.description,i(e)],"\n")})}};var i}),{});function j(e){return"FieldDefinition"===e.kind}function $(e,n){return!!e.find((e=>e.name.value===n.name.value))}function C(e,n){const i=[...n];for(const t of e){const e=i.findIndex((e=>e.name.value===t.name.value));if(e>-1){const n=i[e];if("ListValue"===n.value.kind){const e=n.value.values,i=t.value.values;n.value.values=P(e,i,((e,n)=>{const i=e.value;return!i||!n.some((e=>e.value===i))}))}else n.value=t.value}else i.push(t)}return i}function R(e=[],n=[],i){const o=i&&i.reverseDirectives,s=o?n:e,r=[...o?e:n].map(((e,n,i)=>{const t=i.findIndex((n=>n.name.value===e.name.value));if(t!==n){const n=i[t];return e.arguments=C(e.arguments,n.arguments),null}return e})).filter(t.pC);for(const t of s)if($(r,t)){const e=r.findIndex((e=>e.name.value===t.name.value)),n=r[e];r[e].arguments=C(t.arguments||[],n.arguments||[])}else r.push(t);return r}function M(e,n){return n?(function(e,n){const i=(0,r.S)(e),t=(0,r.S)(n),o=new RegExp("(directive @w*d*)|( on .*$)","g");if(i.replace(o,"")!==t.replace(o,""))throw new Error(`Unable to merge GraphQL directive "${e.name.value}". \nExisting directive:  \n\t${t} \nReceived directive: \n\t${i}`)}(e,n),{...e,locations:[...n.locations,...e.locations.filter((e=>!function(e,n){return n.some((({value:n})=>n===e.value))}(e,n.locations)))]}):e}function P(e,n,i){return e.concat(n.filter((n=>i(n,e))))}function Y(e,n,i){if(null==i?void 0:i.consistentEnumMerge){const i=[];e&&i.push(...e),e=n,n=i}const o=new Map;if(e)for(const t of e)o.set(t.name.value,t);if(n)for(const t of n){const e=t.name.value;if(o.has(e)){const n=o.get(e);n.description=t.description||n.description,n.directives=R(t.directives,n.directives)}else o.set(e,t)}const s=[...o.values()];return i&&i.sort&&s.sort(t.YU),s}function L(e,n,i){return n?{name:e.name,description:e.description||n.description,kind:i&&i.convertExtensions||"EnumTypeDefinition"===e.kind||"EnumTypeDefinition"===n.kind?"EnumTypeDefinition":"EnumTypeExtension",loc:e.loc,directives:R(e.directives,n.directives,i),values:Y(e.values,n.values,i)}:i&&i.convertExtensions?{...e,kind:"EnumTypeDefinition"}:e}function U(e){let n=e;for(;n.kind===a.h.LIST_TYPE||"NonNullType"===n.kind;)n=n.type;return n}function V(e){return e.kind!==a.h.NAMED_TYPE}function B(e){return e.kind===a.h.LIST_TYPE}function H(e){return e.kind===a.h.NON_NULL_TYPE}function q(e){return B(e)?`[${q(e.type)}]`:H(e)?`${q(e.type)}!`:e.name.value}var W;function Q(e,n){return null==e&&null==n?W.A_EQUALS_B:null==e?W.A_SMALLER_THAN_B:null==n?W.A_GREATER_THAN_B:e<n?W.A_SMALLER_THAN_B:e>n?W.A_GREATER_THAN_B:W.A_EQUALS_B}function G(e,n,i){const t=e.find((e=>e.name.value===n.name.value));if(t&&!(null==i?void 0:i.ignoreFieldConflicts)){const e=U(t.type),i=U(n.type);if(e.name.value!==i.name.value)throw new Error(`Field "${n.name.value}" already defined with a different type. Declared as "${e.name.value}", but you tried to override with "${i.name.value}"`)}return!!t}function X(e,n,i,o){const s=[];if(null!=i&&s.push(...i),null!=n)for(const t of n)if(G(s,t,o)){const n=s.find((e=>e.name.value===t.name.value));(null==o?void 0:o.ignoreFieldConflicts)||((null==o?void 0:o.throwOnConflict)?J(e,n,t,!1):J(e,n,t,!0),H(t.type)&&!H(n.type)&&(n.type=t.type)),n.arguments=N(t.arguments||[],n.arguments||[],o),n.directives=R(t.directives,n.directives,o),n.description=t.description||n.description}else s.push(t);if(o&&o.sort&&s.sort(t.YU),o&&o.exclusions){const n=o.exclusions;return s.filter((i=>!n.includes(`${e.name.value}.${i.name.value}`)))}return s}function J(e,n,i,o=!1){const s=q(n.type),r=q(i.type);if((0,t.LN)(s,r)&&!1===K(n.type,i.type,o))throw new Error(`Field '${e.name.value}.${n.name.value}' changed type from '${s}' to '${r}'`)}function K(e,n,i=!1){if(!V(e)&&!V(n))return e.toString()===n.toString();if(H(n)){return K(H(e)?e.type:e,n.type)}return H(e)?K(n,e,i):!!B(e)&&(B(n)&&K(e.type,n.type)||H(n)&&K(e,n.type))}function Z(e,n,i){if(n)try{return{name:e.name,description:e.description||n.description,kind:i&&i.convertExtensions||"InputObjectTypeDefinition"===e.kind||"InputObjectTypeDefinition"===n.kind?"InputObjectTypeDefinition":"InputObjectTypeExtension",loc:e.loc,fields:X(e,e.fields,n.fields,i),directives:R(e.directives,n.directives,i)}}catch(t){throw new Error(`Unable to merge GraphQL input type "${e.name.value}": ${t.message}`)}return i&&i.convertExtensions?{...e,kind:"InputObjectTypeDefinition"}:e}function z(e,n,i){if(n)try{return{name:e.name,description:e.description||n.description,kind:i&&i.convertExtensions||"InterfaceTypeDefinition"===e.kind||"InterfaceTypeDefinition"===n.kind?"InterfaceTypeDefinition":"InterfaceTypeExtension",loc:e.loc,fields:X(e,e.fields,n.fields,i),directives:R(e.directives,n.directives,i)}}catch(t){throw new Error(`Unable to merge GraphQL interface "${e.name.value}": ${t.message}`)}return i&&i.convertExtensions?{...e,kind:"InterfaceTypeDefinition"}:e}function ee(e=[],n=[],i={}){const o=[...n,...e.filter((e=>{return i=e,!n.find((e=>e.name.value===i.name.value));var i}))];return i&&i.sort&&o.sort(t.YU),o}function ne(e,n,i){if(n)try{return{name:e.name,description:e.description||n.description,kind:i&&i.convertExtensions||"ObjectTypeDefinition"===e.kind||"ObjectTypeDefinition"===n.kind?"ObjectTypeDefinition":"ObjectTypeExtension",loc:e.loc,fields:X(e,e.fields,n.fields,i),directives:R(e.directives,n.directives,i),interfaces:ee(e.interfaces,n.interfaces,i)}}catch(t){throw new Error(`Unable to merge GraphQL type "${e.name.value}": ${t.message}`)}return i&&i.convertExtensions?{...e,kind:"ObjectTypeDefinition"}:e}function ie(e,n,i){return n?{name:e.name,description:e.description||n.description,kind:i&&i.convertExtensions||"ScalarTypeDefinition"===e.kind||"ScalarTypeDefinition"===n.kind?"ScalarTypeDefinition":"ScalarTypeExtension",loc:e.loc,directives:R(e.directives,n.directives,i)}:i&&i.convertExtensions?{...e,kind:"ScalarTypeDefinition"}:e}function te(e,n,i){return n?{name:e.name,description:e.description||n.description,directives:R(e.directives,n.directives,i),kind:i&&i.convertExtensions||"UnionTypeDefinition"===e.kind||"UnionTypeDefinition"===n.kind?"UnionTypeDefinition":"UnionTypeExtension",loc:e.loc,types:ee(e.types,n.types,i)}:i&&i.convertExtensions?{...e,kind:"UnionTypeDefinition"}:e}!function(e){e[e.A_SMALLER_THAN_B=-1]="A_SMALLER_THAN_B",e[e.A_EQUALS_B=0]="A_EQUALS_B",e[e.A_GREATER_THAN_B=1]="A_GREATER_THAN_B"}(W||(W={}));const oe={query:"Query",mutation:"Mutation",subscription:"Subscription"};function se(e=[],n=[]){const i=[];for(const t in oe){const o=e.find((e=>e.operation===t))||n.find((e=>e.operation===t));o&&i.push(o)}return i}function re(e,n,i){return n?{kind:e.kind===a.h.SCHEMA_DEFINITION||n.kind===a.h.SCHEMA_DEFINITION?a.h.SCHEMA_DEFINITION:a.h.SCHEMA_EXTENSION,description:e.description||n.description,directives:R(e.directives,n.directives,i),operationTypes:se(e.operationTypes,n.operationTypes)}:(null==i?void 0:i.convertExtensions)?{...e,kind:a.h.SCHEMA_EXTENSION}:e}const le="SCHEMA_DEF_SYMBOL";function ae(e,n){g();const i={kind:a.h.DOCUMENT,definitions:ue(e,{useSchemaDefinition:!0,forceSchemaDefinition:!1,throwOnConflict:!1,commentDescriptions:!1,...n})};let t;var o;return n&&n.commentDescriptions?(o=i,t=(0,s.Vn)(o,w)):t=i,g(),t}function ce(e,n,i=[],o=new Set){if(e&&!o.has(e))if(o.add(e),"function"==typeof e)ce(e(),n,i,o);else if(Array.isArray(e))for(const t of e)ce(t,n,i,o);else if((0,c.nN)(e)){ce((0,t.HA)(e,n).definitions,n,i,o)}else if("string"==typeof e||function(e){return e instanceof l.H}(e)){ce((0,u.Qc)(e,n).definitions,n,i,o)}else if("object"==typeof e&&(0,d.Ir)(e))i.push(e);else{if(!(0,t.JW)(e))throw new Error("typeDefs must contain only strings, documents, schemas, or functions, got "+typeof e);ce(e.definitions,n,i,o)}return i}function ue(e,n){var i,t,o;g();const s=function(e,n){var i,t,o;const s={};for(const r of e)if("name"in r){const e=null===(i=r.name)||void 0===i?void 0:i.value;if((null==n?void 0:n.commentDescriptions)&&x(r),null==e)continue;if((null===(t=null==n?void 0:n.exclusions)||void 0===t?void 0:t.includes(e+".*"))||(null===(o=null==n?void 0:n.exclusions)||void 0===o?void 0:o.includes(e)))delete s[e];else switch(r.kind){case a.h.OBJECT_TYPE_DEFINITION:case a.h.OBJECT_TYPE_EXTENSION:s[e]=ne(r,s[e],n);break;case a.h.ENUM_TYPE_DEFINITION:case a.h.ENUM_TYPE_EXTENSION:s[e]=L(r,s[e],n);break;case a.h.UNION_TYPE_DEFINITION:case a.h.UNION_TYPE_EXTENSION:s[e]=te(r,s[e],n);break;case a.h.SCALAR_TYPE_DEFINITION:case a.h.SCALAR_TYPE_EXTENSION:s[e]=ie(r,s[e],n);break;case a.h.INPUT_OBJECT_TYPE_DEFINITION:case a.h.INPUT_OBJECT_TYPE_EXTENSION:s[e]=Z(r,s[e],n);break;case a.h.INTERFACE_TYPE_DEFINITION:case a.h.INTERFACE_TYPE_EXTENSION:s[e]=z(r,s[e],n);break;case a.h.DIRECTIVE_DEFINITION:s[e]=M(r,s[e])}}else r.kind!==a.h.SCHEMA_DEFINITION&&r.kind!==a.h.SCHEMA_EXTENSION||(s[le]=re(r,s[le],n));return s}(ce(e,n),n);if(null==n?void 0:n.useSchemaDefinition){const e=s[le]||{kind:a.h.SCHEMA_DEFINITION,operationTypes:[]},n=e.operationTypes;for(const i in oe){if(!n.find((e=>e.operation===i))){const e=s[oe[i]];null!=e&&null!=e.name&&n.push({kind:a.h.OPERATION_TYPE_DEFINITION,type:{kind:a.h.NAMED_TYPE,name:e.name},operation:i})}}null!=(null===(i=null==e?void 0:e.operationTypes)||void 0===i?void 0:i.length)&&e.operationTypes.length>0&&(s[le]=e)}(null==n?void 0:n.forceSchemaDefinition)&&!(null===(o=null===(t=s[le])||void 0===t?void 0:t.operationTypes)||void 0===o?void 0:o.length)&&(s[le]={kind:a.h.SCHEMA_DEFINITION,operationTypes:[{kind:a.h.OPERATION_TYPE_DEFINITION,operation:"query",type:{kind:a.h.NAMED_TYPE,name:{kind:a.h.NAME,value:"Query"}}}]});const r=Object.values(s);if(null==n?void 0:n.sort){const e="function"==typeof n.sort?n.sort:Q;r.sort(((n,i)=>{var t,o;return e(null===(t=n.name)||void 0===t?void 0:t.value,null===(o=i.name)||void 0===o?void 0:o.value)}))}return r}function de(e){return(0,t.Ee)(e)}function fe(e,n){e&&(e.extensions=(0,t.Ee)([e.extensions||{},n||{}]))}function ve(e){const n={schemaExtensions:{},types:{}};return function(e,n){n.onSchema(e);const i=e.getTypeMap();for(const[,t]of Object.entries(i)){const e=(0,f.KA)(t)&&(0,v.u1)(t),i=(0,p.s9)(t);if(!e&&!i)if((0,f.lp)(t)){n.onObjectType(t);const e=t.getFields();for(const[,i]of Object.entries(e)){n.onObjectField(t,i);const e=i.args||[];for(const o of e)n.onObjectFieldArg(t,i,o)}}else if((0,f.oT)(t)){n.onInterface(t);const e=t.getFields();for(const[,i]of Object.entries(e)){n.onInterfaceField(t,i);const e=i.args||[];for(const o of e)n.onInterfaceFieldArg(t,i,o)}}else if((0,f.hL)(t)){n.onInputType(t);const e=t.getFields();for(const[,i]of Object.entries(e))n.onInputFieldType(t,i)}else if((0,f.EN)(t))n.onUnion(t);else if((0,f.KA)(t))n.onScalar(t);else if((0,f.EM)(t)){n.onEnum(t);for(const e of t.getValues())n.onEnumValue(t,e)}}}(e,{onSchema:e=>n.schemaExtensions=e.extensions||{},onObjectType:e=>n.types[e.name]={fields:{},type:"object",extensions:e.extensions||{}},onObjectField:(e,i)=>n.types[e.name].fields[i.name]={arguments:{},extensions:i.extensions||{}},onObjectFieldArg:(e,i,t)=>n.types[e.name].fields[i.name].arguments[t.name]=t.extensions||{},onInterface:e=>n.types[e.name]={fields:{},type:"interface",extensions:e.extensions||{}},onInterfaceField:(e,i)=>n.types[e.name].fields[i.name]={arguments:{},extensions:i.extensions||{}},onInterfaceFieldArg:(e,i,t)=>n.types[e.name].fields[i.name].arguments[t.name]=t.extensions||{},onEnum:e=>n.types[e.name]={values:{},type:"enum",extensions:e.extensions||{}},onEnumValue:(e,i)=>n.types[e.name].values[i.name]=i.extensions||{},onScalar:e=>n.types[e.name]={type:"scalar",extensions:e.extensions||{}},onUnion:e=>n.types[e.name]={type:"union",extensions:e.extensions||{}},onInputType:e=>n.types[e.name]={fields:{},type:"input",extensions:e.extensions||{}},onInputFieldType:(e,i)=>n.types[e.name].fields[i.name]={extensions:i.extensions||{}}}),n}const pe={requireResolversForArgs:"ignore",requireResolversForNonScalar:"ignore",requireResolversForAllFields:"ignore",requireResolversForResolveType:"ignore",requireResolversToMatchSchema:"ignore"};function me(e){const n=ae([e.schemas,e.typeDefs||[]],e),i=[],o=[];for(const s of e.schemas)i.push((0,t.wq)(s)),o.push(ve(s));i.push(...ye(e));return Te({resolvers:h(i,e),typeDefs:n,extensions:de(o)},e)}function ye(e){return e.resolvers?(0,t._2)(e.resolvers):[]}function Te({resolvers:e,typeDefs:n,extensions:i},t){let o="string"==typeof n?(0,m.I)(n,t):(0,m.M)(n,t);return e&&(o=T({schema:o,resolvers:e,resolverValidationOptions:{...pe,...t.resolverValidationOptions||{}}})),function(e,n){fe(e,n.schemaExtensions);for(const[i,t]of Object.entries(n.types||{})){const n=e.getType(i);if(n)if(fe(n,t.extensions),"object"===t.type||"interface"===t.type)for(const[e,i]of Object.entries(t.fields)){const t=n.getFields()[e];if(t){fe(t,i.extensions);for(const[e,n]of Object.entries(i.arguments))fe(t.args.find((n=>n.name===e)),n)}}else if("input"===t.type)for(const[e,i]of Object.entries(t.fields))fe(n.getFields()[e],i.extensions);else if("enum"===t.type)for(const[e,i]of Object.entries(t.values))fe(n.getValue(e),i)}}(o,i),o}}}]);